<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visualisation de bobinage</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #141822;
    --plot-bg: #1e1e1e; /* pas noir noir */
    --fg: #e6e6e6;
    --muted: #9aa4b2;
    --accent: #6ea8fe;
    --bad: #ff7676;
    --warn: #ffc86b;
    --good: #66d587;
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  .wrap {
    max-width: 1100px; margin: 24px auto; padding: 0 16px;
  }
  h1 { font-size: 22px; margin: 0 0 16px; font-weight: 700; }
  .grid {
    display: grid; gap: 16px;
    grid-template-columns: 320px 1fr;
  }
  .card {
    background: var(--panel); border-radius: 14px; padding: 14px 14px 10px; box-shadow: 0 6px 20px rgb(0 0 0 / 25%);
  }
  .controls label { display: block; font-size: 12px; color: var(--muted); margin: 10px 0 6px; }
  select, input[type="number"]{
    width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3142;
    background: #0f1320; color: var(--fg); outline: none;
  }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .btn {
    display: inline-block; background: var(--accent); color: #0b1220; font-weight: 700;
    padding: 10px 12px; border-radius: 10px; border: none; cursor: pointer; margin-top: 10px;
  }
  .btn:active { transform: translateY(1px); }
  .plot-card { position: relative; }
  canvas { width: 100%; aspect-ratio: 1 / 1; background: var(--plot-bg); border-radius: 14px; display: block; }
  .legend { font-size: 12px; color: var(--muted); margin-top: 8px; }

  .kpi {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 10px;
  margin-top: 10px;
}
.kpi .box {
  background: #0f1320;
  border: 1px solid #2a3142;
  border-radius: 12px;
  padding: 10px;
}


  
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .note { color: var(--muted); font-size: 12px; }
  .warn { color: var(--warn); }
  .bad  { color: var(--bad); }
  .good { color: var(--good); }
  @media (max-width: 960px) { .grid { grid-template-columns: 1fr; } /*canvas { height: 520px; }*/ }
</style>
</head>
<body>
<div class="wrap">
  <h1>Visualisation du bobinage d’une machine électrique</h1>
  <div class="grid">
    <div class="card controls">
      <div class="row">
        <div>
          <label>Nombre de pôles</label>
          <select id="poles"></select>
        </div>
        <div>
          <label>Nombre d’encoches</label>
          <select id="slots"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Nombre de couches</label>
          <select id="layers"></select>
        </div>
        <div>
          <label>Pas de bobine (en nombre d'encoches)</label>
          <select id="coilSpan"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Afficher têtes de bobines ?</label>
          <select id="endTurns">
            <option value="1">Oui</option>
            <option value="0" selected>Non</option>
          </select>
        </div>
        <div>
          <label>Voir domaine électrique ?</label>
          <select id="elecDomain">
            <option value="1">Oui</option>
            <option value="0" selected>Non</option>
          </select>
        </div>
      </div>
      <button class="btn" id="go">Tracer / Calculer</button>
      <div class="note" id="messages"></div>
      <div class="kpi">
        <div class="box"><div class="note">Facteur de bobinage | <span class="mono">kw</span></div><div id="kw" class="mono">–</div></div>
        <div class="box"><div class="note">Ondulations couple (par tour)</div><div id="torque" class="mono">–</div></div>
        <div class="box"><div class="note">Sections identiques</div><div id="sections" class="mono">–</div></div>
        <div class="box"><div class="note">Type</div><div id="wtype" class="mono">–</div></div>
      </div>
    </div>

    <div class="card plot-card">
      <canvas id="plot" width="1000" height="1000"></canvas>
      <div class="legend">© 2025 Granizo Maxime. Tous droits réservés.      </div>
    </div>
  </div>
</div>

<!-- <script src="https://cdn.jsdelivr.net/npm/mathjs@11/lib/browser/math.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fft.js/dist/fft.min.js"></script>


 -->

  <!-- <script>
    const { create, all } = math;
    const FFT = window.FFT; // exposé par fft.js
    const mathjs = create(all);

    const TAU = Math.PI * 2;

    // ton code ici...
//   </script>
  -->
 <script> 



/* ===========================
   1) Petites utilitaires
=========================== */

const TAU = Math.PI * 2;

const clamp = (x,a,b)=>Math.min(b,Math.max(a,x));

function deg(x){ return x*180/Math.PI; }

function mod(a, n){ return ((a % n) + n) % n; }

function numberToLetter(n){ return String.fromCharCode('a'.charCodeAt(0) + (parseInt(n,10) - 1)); }

function angleInSector(angle, center, width){
  angle = +angle; center = +center;
  angle = +(mod(angle, TAU)).toFixed(6);
  center = mod(center, TAU);
  const half = width/2;
  const lower = +(mod(center - half, TAU)).toFixed(6);
  const upper = +(mod(center + half, TAU)).toFixed(6);
  if (lower < upper) return (lower < angle && angle <= upper);
  return (angle > lower || angle <= upper);
}

// Fonction pour tracer un trait et retirer les points
      const drawAndRemove = (p,s,j, retList,clone_labelPositions,color,offsetDistance ) => {
        if (!retList || retList.length === 0) return;
        const mPos = retList.shift(); // prendre et retirer le point
        // retirer aussi le point initial p du clone
        const indexP = clone_labelPositions[s][j]["+"].findIndex(pt => pt === p);
        if (indexP >= 0) clone_labelPositions[s][j]["+"].splice(indexP, 1);

        const dx = mPos.x - p.x;
        const dy = mPos.y - p.y;
        const length = Math.sqrt(dx*dx + dy*dy);
        const ux = dx / length;
        const uy = dy / length;

        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(p.x + offsetDistance * ux, p.y + offsetDistance * uy);
        ctx.lineTo(mPos.x - offsetDistance * ux, mPos.y - offsetDistance * uy);
        ctx.stroke();
      };


/* ===========================
   2) Listes dynamiques
=========================== */
function layersPossibilitiesList(nb_slot, nb_pole){
  nb_slot = +nb_slot; nb_pole = +nb_pole;
  // même logique que ton app.py
  if (parseInt(nb_slot/2) !== nb_slot/2){
    return [2,4,6,8];
  } else {
    return [1,2,4,6,8];
  }
}
function coilSpanPossibilitiesList(nb_layer, nb_slot, nb_pole){
  nb_layer = +nb_layer; nb_slot = +nb_slot; nb_pole = +nb_pole;
  const m = 3;
  if (nb_slot/(nb_pole*m) < 1) return [1];
  const arr = [];
  for (let k=Math.floor(nb_slot/2); k>=1; k--) arr.push(k);
  return arr;
}

/* ===========================
   3) Caractéristiques bobinage
=========================== */
function ppcm(a,b){ return (a*b)/gcd(a,b); }

function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a; }

function calculateWindingCharacteristics(m, Ns, p, nb_layers, coil_span, silent=false){
  m=+m; Ns=+Ns; p=+p; nb_layers=+nb_layers; coil_span=+coil_span;
  const q = Ns / p / m;               // encoches/pôle/phase
  const pole_pairs = p/2;
  const f_torque = ppcm(p, Ns);       // fréq. ondulations (par tour)
  const nb_of_identic_sections = gcd(Ns, p); // sections identiques
  // Heuristique type de bobinage (aligné avec ton app.py)
  let winding_type = '';
  // if (Ns/(m*p) < 1){
  //   winding_type = 'Bobinage concentré';
  // } else {
    if (coil_span === 1){
      winding_type = 'Bobinage à pas dentaire';
    } else if (Number.isInteger(Ns/(m*p))){
      winding_type = 'Bobinage distribué à nombre d’encoches par pôle et par phase entier';
    } else {
      winding_type = 'Bobinage distribué à pas raccourcit';
    }
  //}
  // drapeaux d’avertissement
  let warning_flag = false;
  if (q < 0.25) warning_flag = true;
  // if (nb_of_identic_sections < 2) warning_flag = true;
  const S = (Ns/(m*gcd(Ns, parseInt(p/2,10))));
  if (S - Math.floor(S) > 0) warning_flag = true;

  return { f_torque, nb_of_identic_sections, winding_type, warning_flag };
}

/* ===========================
   4) FFT minimale (DFT) pour kw
=========================== */
function dftComplex(x){
  // x: array de réels → retourne spectre complexe {re, im}
  const N = x.length;
  const out = new Array(N).fill(0).map(()=>({re:0, im:0}));
  for (let k=0; k<N; k++){
    let re=0, im=0;
    for (let n=0; n<N; n++){
      const ang = -2*Math.PI*k*n/N;
      const c = Math.cos(ang), s = Math.sin(ang);
      re += x[n]*c; im += x[n]*s;
    }
    out[k] = {re, im};
  }
  return out;
}
function complexAbs(z){ return Math.hypot(z.re, z.im); }

/* ===========================
   5) Dessins (canvas)
=========================== */
const canvas = document.getElementById('plot');
const ctx = canvas.getContext('2d');

function clearPlot(){
  ctx.save();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--plot-bg');
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.restore();
}

// conv polaire → écran
function P(r, th, cx, cy, scale){
  return [cx + r*Math.cos(th)*scale, cy + r*Math.sin(th)*scale];
}



function drawStator(nb_slots, nb_layer){
    const cx = canvas.width/2, cy = canvas.height/2;
    const scale = 380;
    const rBase = 0.85 + 0.05 * nb_layer;
    const toothH = 0.23 + 0.05 * nb_layer;
    const slotPitch = TAU/nb_slots;
    const statorThick = 0.1;
    const slot_opening = 0.4; // 0 = pas de pied de dent , 1 = pieds connectés
    const labelRadius = rBase - statorThick/2;
    const rOuter = rBase ;
    const rInner = (rBase - statorThick) ;
    const rToothBase = (rBase - toothH) ;

    // --- Pieds de dent avec arc ---
    const shoeWidth = slotPitch * 0.7;    // largeur de l’arc
    const shoeDepth = 0.05 ;       // rayon intérieur
    const slopeRatio = 0.1;               // pente vers la dent


    const rShoe = rToothBase - shoeDepth;     // rayon de l'arc
    const rSlope = rToothBase*0.9;                // rayon de la dent

    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#dadde4';
    ctx.globalAlpha = 0.35;
    
    ctx.beginPath();

    // --- Couronne ---
    ctx.arc(cx, cy, rOuter*scale, 0, TAU);
    ctx.arc(cx, cy, rInner*scale, 0, TAU, true);
    // ctx.closePath();

    // ctx.fill();
    // ctx.stroke();

    // --- Dents ---
    const toothWidth = slotPitch * 0.4;
    for(let s=0; s<nb_slots; s++){
        const angle = (0.5 + s) * slotPitch;
        const w = toothWidth/2;

        // --- Arc du pied de dent avec pente intermédiaire ---

        // Points intermédiaires pour la pente
        const [xStartSlope, yStartSlope] = P(rSlope, angle - w - (slotPitch-toothWidth)/2 * (slot_opening), cx, cy,scale);
        const [xEndSlope, yEndSlope]     = P(rSlope, angle + w + (slotPitch-toothWidth)/2 * (slot_opening), cx, cy,scale);

        // Points à la base de la dent
        const [xStartDent, yStartDent] = P(rToothBase, angle - w, cx, cy,scale);
        const [xEndDent, yEndDent]     = P(rToothBase, angle + w, cx, cy,scale);

        const [xStartDent1, yStartDent1] = P(rToothBase*0.95, angle + w + (slotPitch-toothWidth)/2 * (slot_opening), cx, cy,scale);
        const [xEndDent1, yEndDent1]     = P(rToothBase*0.95, angle - w - (slotPitch-toothWidth)/2 * (slot_opening), cx, cy,scale);



        const [x1,y1] = P(rToothBase, angle - w, cx, cy,scale);
        const [x2,y2] = P(rOuter, angle - w, cx, cy,scale);
        const [x3,y3] = P(rOuter, angle + w, cx, cy,scale);
        const [x4,y4] = P(rToothBase, angle + w, cx, cy,scale); // bas du pied de dent gauche

        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.lineTo(x3,y3);
        ctx.lineTo(x4,y4);

        // pied de dent
        ctx.lineTo(xStartDent1, yStartDent1);   // base pied de dent gauche
        ctx.lineTo(xEndSlope, yEndSlope);     // bas de pente droite

        ctx.arc(cx, cy, rSlope*scale, angle + 1.4 * w, angle - 1.4 * w, true);

        ctx.lineTo(xStartSlope, yStartSlope); // bas de pente gauche
        ctx.lineTo(xEndDent1, yEndDent1);       // base dent droite


        ctx.closePath();

        // numéro de l'encoche
        const [xt, yt] = P(labelRadius, -s*slotPitch, cx, cy, scale);
        // ctx.fillStyle = color;
        // ctx.font = "16px Arial";
        ctx.font = "bold 16px Arial";  // texte en gras
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(s+1  , xt, yt);
    }

ctx.fill();
ctx.restore();
}


function drawMagnets(nb_poles){
  const cx = canvas.width/2, cy = canvas.height/2, scale=380;
  const polePitch = TAU/nb_poles;
  const rInner = 0.35, rOuter = 0.52;
  ctx.save();

    // --- Couronne ---
    ctx.beginPath();
    ctx.arc(cx, cy, (rInner+rOuter)/2*scale, 0, TAU);
    ctx.arc(cx, cy, rInner*scale, 0, TAU, true);
    ctx.closePath();
    ctx.strokeStyle = '#000';
    ctx.fillStyle = '#dadde4';
    ctx.globalAlpha = 0.35;
    ctx.fill();
    ctx.globalAlpha = 1;


  for (let k=0; k<nb_poles; k++){
    const start = k*polePitch, end = (k+1)*polePitch;
    ctx.beginPath();
    // wedge
    ctx.moveTo(...P(0,0,cx,cy,scale));
    ctx.arc(cx,cy, rOuter*scale, start, end);
    ctx.lineTo(...P((rInner+rOuter)/2, end, cx,cy,scale));
    ctx.arc(cx,cy, (rInner+rOuter)/2*scale, end, start, true);
    ctx.closePath();
    ctx.fillStyle = (k%2===0) ? 'rgba(255,80,80,0.6)' : 'rgba(80,140,255,0.6)';
    ctx.fill();
  }
  ctx.restore();
}

/* ===========================
   6) Star of slots + distribution
=========================== */ 
 
  function starOfSlots(winding_type, m, nb_poles, nb_slots, nb_layers, options){ 
  const { electrical=false, raccourcissement=0, plotEndTurns=false, legend=false, silent=true } = options||{};
  const poles_pair = nb_poles/2;
  const phaseLabels = ['A','B','C','D','E','F'].slice(0,m);
  const phaseColors = ['#ff4d4d','#4d80ff','#31c159','#ffa640','#a56bff','#27c0d8'].slice(0,m);
  const sectorWidth = Math.PI/m;
  const slotPitch = 2*Math.PI/nb_slots;
  const phasors = Object.fromEntries(phaseLabels.map(L=>[L,[]]));
  const CD = Array.from({length: nb_slots}, ()=>Array(m).fill(0));
  let warning_flag = false;

  let coil_span_nb = 1;
  if (winding_type.includes("raccourcit") || winding_type.includes("entier")){
    coil_span_nb = Math.max(1, +raccourcissement);
  }
  const turnsWeight = 1/Math.max(nb_layers,1);

  let previous_slot = -1;

  for (let k=0; k<Math.floor(nb_layers*nb_slots/2); k++){
    // Détermination de la bobine aller/retour
    let go = (previous_slot + 1) % nb_slots;
    let ret = (go + coil_span_nb) % nb_slots;
    let counter = 0;
    while ((Math.abs(CD[go].reduce((a,b)=>a+Math.abs(b),0)) >= 1 ||
            Math.abs(CD[ret].reduce((a,b)=>a+Math.abs(b),0)) >= 1) && counter <= go){
      go = (go + 1) % nb_slots;
      ret = (go + coil_span_nb) % nb_slots;
      counter++;
    }
    if (counter > go){
      if(!silent) console.log("⚠️ Winding not possible at idx", k);
      warning_flag = true;
    }

    previous_slot = go;

    const angle_mech = -go*slotPitch;
    const angle_elec = angle_mech*poles_pair + Math.PI/6;

    // Attribution phase et polarité
    let phaseIdx=-1, polarity=1;
    for (let j=0;j<m;j++){
      const centerPos = -2*Math.PI*j/m;
      const centerNeg = centerPos + Math.PI;
      if (angleInSector(angle_elec, centerPos, sectorWidth)){ phaseIdx=j; polarity=+1; break; }
      if (angleInSector(angle_elec, centerNeg, sectorWidth)){ phaseIdx=j; polarity=-1; break; }
    }
    if (phaseIdx<0){ warning_flag=true; continue; }

    // Mise à jour de la distribution des conducteurs
    CD[go][phaseIdx] +=  polarity*turnsWeight;
    CD[ret][phaseIdx] += -polarity*turnsWeight;

    // Stockage des phasors pour le tracé électrique
    const phaseLbl = phaseLabels[phaseIdx];
    if(electrical) phasors[phaseLbl].push({slot: go, sign: polarity});
  }

  // ==================== TRACÉ ====================
  
  if (electrical) {
  ctx.save();
  const cx = canvas.width / 2, cy = canvas.height / 2, scale = 380;
  const radiusPhasor = 0.7;  // longueur du phasor
  const labelRadius = 0.8;   // rayon pour placer le texte
  const delta = 0.09;        // espacement radial entre conducteurs superposés

  // compteur pour gérer la superposition des labels par angle
  const labelCountAtAngle = {};

  for (let s = 0; s < nb_slots; s++) {
    for (let j = 0; j < m; j++) {
      const w = CD[s][j];
      if (w === 0) continue;

      const color = phaseColors[j];
      const theta = mod(s * slotPitch * poles_pair,2*Math.PI);  // angle mécanique * paires de pôles

      // clé arrondie pour éviter les problèmes de flottants
      const key = Math.round(theta * 1e6) / 1e6;

      // nombre de conducteurs à cet angle déjà placés
      let nLabel = labelCountAtAngle[key] || 0;

      // nombre de conducteurs à tracer pour cette phase et slot
      const nConductors = Math.round(Math.abs(w) * nb_layers);

      // tracer tous les conducteurs
      for (let k = 0; k < nConductors; k++) {
        // coordonnées du phasor
        const [x, y] = P(radiusPhasor, theta, cx, cy, scale);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x, y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5 + 0.5 * nLabel;
        ctx.stroke();

        // symbole : rond pour positif, croix pour négatif
        if (w > 0) {
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.moveTo(x - 6, y - 6);
          ctx.lineTo(x + 6, y + 6);
          ctx.moveTo(x - 6, y + 6);
          ctx.lineTo(x + 6, y - 6);
          ctx.lineWidth = 1.5 + 0.5 * nLabel;
          ctx.strokeStyle = color;
          ctx.stroke();
        }

        // texte radialement décalé pour éviter superposition
        const [xt, yt] = P(labelRadius + nLabel * delta, theta, cx, cy, scale);
        ctx.fillStyle = color;
        ctx.font = "bold 16px Arial";  // texte en gras
        // ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`S${s + 1}` + (w > 0 ? "+" : "-"), xt, yt);

        // incrément compteur pour ce slot/angle
        nLabel++;
      }

      // mettre à jour le compteur global pour cet angle
      labelCountAtAngle[key] = nLabel;
    }
  }

  ctx.restore();
}
 
  
  else { // Domaine mécanique
   

ctx.save();
ctx.font = "14px Arial";
ctx.font = "bold 14px Arial";  // texte en gras
ctx.textAlign = "center";
ctx.textBaseline = "middle";
const cx = canvas.width / 2, cy = canvas.height / 2, scale = 380;

const labelRadiusBase = 0.7; // rayon de base pour le label
const angleOffset = 0.04;      // petit décalage angulaire pour bobinage concentré

const slotConductorsCount = Array(nb_slots).fill(0).map(()=>0);


// objet pour stocker les positions des labels pour chaque slot, phase et signe
// const labelPositions = Array(nb_slots).fill(0).map(()=>Array(m).fill(0).map(()=>({"+":[], "-":[] })));
const labelPositions = Array(nb_slots).fill(0).map(() =>
  Array(m).fill(0).map(() => ({ "+": [], "-": [] }))
);


for(let s=0; s<nb_slots; s++){ // itère sur les slots
  for(let j=0; j<m; j++){      // itère sur les phases
    const w = CD[s][j];
    if(w === 0) continue;

    const color = phaseColors[j];
    const thetaBase = s * slotPitch;

    // nombre de conducteurs dans cette slot pour cette phase
    const nConductors = Math.round(Math.abs(w) * nb_layers);

    for(let k=0; k<nConductors; k++){  // répéter pour chaque conducteur

      const label = phaseLabels[j] + (w>0 ? "+" : "-");

      let thetaLabel, radiusLabel;
      radiusLabel = labelRadiusBase;

      if (winding_type.includes("Bobinage à pas dentaire")) {  // Concentré :  petit décalage angulaire

        const radiusMin = labelRadiusBase;
        const radiusMax = labelRadiusBase + 0.05 * (nb_layers - 1);
        slotConductorsCount[s] += 1; // conducteur suivant dans la même encoche

        if (nb_layers==1) {thetaLabel = thetaBase}
        else{
            if( (CD[mod(s+1,nb_slots)][j]>0 && w<0) || (CD[mod(s+1,nb_slots)][j]<0 && w>0 )) { // si il y a un autre conducteur de polarité opposé au slot suivant
              
              if((CD[(s+nb_slots-1)%nb_slots][j]>0 && w<0) || (CD[(s+nb_slots-1)%nb_slots][j]<0 && w>0)) { // si il y a un autre conducteur au slot précédent aussi  
                thetaLabel = thetaBase - angleOffset + (slotConductorsCount[s]-1)%2 *2*  angleOffset ;  // répartir droite/gauche

                if(nb_layers>2){
                  radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *Math.floor(k/2) ;}
              }

              else{ // sinon s'il y a un conducteur au slot suivant mais pas au slot précédent

              thetaLabel = thetaBase + angleOffset;   // le mettre : côté droit
              if(nb_layers>2){radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *(k) ;}
                  }

            }
            else {         // sinon, si pas de conducteur au slot suivant, on met à gauche
                thetaLabel = thetaBase - angleOffset;
                if(nb_layers>2){radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *(k) ;}
              }
              
            }
      } 
else {
  // Distribué : répartir les conducteurs uniformément selon la couche
  const radiusMin = labelRadiusBase;
  const radiusMax = labelRadiusBase + 0.05 * (nb_layers - 1);

  if(nb_layers==1){radiusLabel = radiusMin ;}
  else{
  radiusLabel = radiusMin + (radiusMax - radiusMin) * slotConductorsCount[s] / (nb_layers - 1);}
  slotConductorsCount[s] += 1; // conducteur suivant

  thetaLabel = thetaBase;
}


      const [xt, yt] = P(radiusLabel, thetaLabel, cx, cy, scale);
      ctx.fillStyle = color;
      ctx.fillText(label, xt, yt);

      // enregistrer la position pour le tracé de tête de bobine
      // let signe;
      // signe = w>0 ? "+" : "-";

      // labelPositions[s][j][signe].push({xt, yt});

      // const sign = w > 0 ? "+" : "-";
      // labelPositions[s][j][sign].push({x: xt, y: yt});
      const sign = w > 0 ? "+" : "-";
      labelPositions[s][j][sign].push({x: xt, y: yt, sign: sign});


      // console.log('signe :', sign);

      // console.log('label :', label);
      // console.log('labelPositions[s][j]:', labelPositions[s][j]);


    }
  }
}


ctx.restore();




if(plotEndTurns) {
  const clone_labelPositions = JSON.parse(JSON.stringify(labelPositions));

  console.log('Plot des bobines');

  ctx.save();
  ctx.lineWidth = 1.2;
  const offsetDistance = 15.0;
  const cx = canvas.width / 2, cy = canvas.height / 2;

  for (let s = 0; s < nb_slots; s++) {
    for (let j = 0; j < m; j++) {
      const color = phaseColors[j];

      // récupérer les positions + et -
      const plusPositions = clone_labelPositions[s][j]["+"].slice();
      const minusPositions = clone_labelPositions[s][j]["-"].slice();

      // // tracer +
      // for (const p of plusPositions) {
      //   let retSlot = mod(s + coil_span_nb, nb_slots);
      //   if (!clone_labelPositions[retSlot][j]["-"] || clone_labelPositions[retSlot][j]["-"].length === 0) {
      //     retSlot = mod(s - coil_span_nb, nb_slots);
      //   }
      //   drawAndRemove(p,s,j, clone_labelPositions[retSlot][j]["-"],clone_labelPositions,color,offsetDistance );
      // }

      // // tracer -
      // for (const p of minusPositions) {
      //   let retSlot = mod(s - coil_span_nb, nb_slots);
      //   if (!clone_labelPositions[retSlot][j]["+"] || clone_labelPositions[retSlot][j]["+"].length === 0) {
      //     retSlot = mod(s + coil_span_nb, nb_slots);
      //   }
      //   drawAndRemove(p,s,j, clone_labelPositions[retSlot][j]["+"],clone_labelPositions,color,offsetDistance );
      // }
  

  

  for (const p of plusPositions) {
  const retSlotPos = mod(s + coil_span_nb, nb_slots); // sens positif
  const retSlotNeg = mod(s - coil_span_nb, nb_slots); // sens négatif

  const hasPos = clone_labelPositions[retSlotPos][j]["-"] && clone_labelPositions[retSlotPos][j]["-"].length > 0;
  const hasNeg = clone_labelPositions[retSlotNeg][j]["-"] && clone_labelPositions[retSlotNeg][j]["-"].length > 0;

  let retSlot = null;

  if (hasPos && !hasNeg) {
    retSlot = retSlotPos;
  } else if (!hasPos && hasNeg) {
    retSlot = retSlotNeg;
  } else if (hasPos && hasNeg) {
    // comparer les distances
    const posCandidate = clone_labelPositions[retSlotPos][j]["-"][0];
    const negCandidate = clone_labelPositions[retSlotNeg][j]["-"][0];

    const dPos = Math.hypot(posCandidate.x - p.x, posCandidate.y - p.y);
    const dNeg = Math.hypot(negCandidate.x - p.x, negCandidate.y - p.y);

    // choisir celui qui est le plus proche
    retSlot = dPos <= dNeg ? retSlotPos : retSlotNeg;
  }

  if (retSlot !== null) {
    drawAndRemove(p, s, j, clone_labelPositions[retSlot][j]["-"], clone_labelPositions, color, offsetDistance);
  }
}



// tracer -
for (const p of minusPositions) {
  const retSlotNeg = mod(s - coil_span_nb, nb_slots); // sens négatif
  const retSlotPos = mod(s + coil_span_nb, nb_slots); // sens positif

  const hasNeg = clone_labelPositions[retSlotNeg][j]["+"] && clone_labelPositions[retSlotNeg][j]["+"].length > 0;
  const hasPos = clone_labelPositions[retSlotPos][j]["+"] && clone_labelPositions[retSlotPos][j]["+"].length > 0;

  let retSlot = null;

  if (hasNeg && !hasPos) {
    retSlot = retSlotNeg;
  } else if (!hasNeg && hasPos) {
    retSlot = retSlotPos;
  } else if (hasNeg && hasPos) {
    // comparer les distances
    const negCandidate = clone_labelPositions[retSlotNeg][j]["+"][0];
    const posCandidate = clone_labelPositions[retSlotPos][j]["+"][0];

    const dNeg = Math.hypot(negCandidate.x - p.x, negCandidate.y - p.y);
    const dPos = Math.hypot(posCandidate.x - p.x, posCandidate.y - p.y);

    // choisir le plus proche
    retSlot = dNeg <= dPos ? retSlotNeg : retSlotPos;
  }

  if (retSlot !== null) {
    drawAndRemove(p, s, j, clone_labelPositions[retSlot][j]["+"], clone_labelPositions, color, offsetDistance);
  }
}





}
  }
  ctx.restore();
}








  }




  return { phasors, Conductors_distribution: CD, warning_flag };
}




function showSectors(ctx, sectors) {
  const R = ctx.canvas.width / 2.5;
  const cx = ctx.canvas.width / 2;
  const cy = ctx.canvas.height / 2;

  ctx.save();

  sectors.forEach(sec => {
    const start = sec.center - sec.width / 2;
    const end   = sec.center + sec.width / 2;

    // --- secteur positif ---
    ctx.globalAlpha = 0.15;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, start, end, false);
    ctx.closePath();
    ctx.fillStyle = sec.color;
    ctx.fill();

    // --- secteur négatif (opposé) ---
    const startOpp = start + Math.PI;
    const endOpp   = end + Math.PI;
    ctx.globalAlpha = 0.07; // plus transparent
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, startOpp, endOpp, false);
    ctx.closePath();
    ctx.fillStyle = sec.color;
    ctx.fill();
  });

  ctx.restore();
}


/* ===========================
   7) Facteur de bobinage (Scuiller)
=========================== */
function calculerFacteurDeBobinage(phasors, CD, nb_slots, nb_poles, m){
  const Q = nb_slots, N = m, p = nb_poles/2;
  // vecteur spatial : (N/Q) * FFT(CD[:,0]) — on suit la colonne phase A
  const space = dftComplex(CD.map(row => row[0]||0)).map(z => ({re: (N/Q)*z.re, im: (N/Q)*z.im}));
  // remappage harmonique électrique : indices = mod(p * [0:Q-1], Q)
  const Kw_he = new Array(Q);
  for (let k=0; k<Q; k++){
    const idx = (p * k) % Q; // p peut être .5, mais dans notre cas nb_poles pair → p entier
    Kw_he[k] = space[idx];
  }
  const fundamental = Kw_he[1];
  return complexAbs(fundamental);
}


// function calculerFacteurDeBobinage(phasors, conductorsDistribution, nbSlots, nbPoles,m,silent = true,showHarmonics = false,interpolationFactor = 5,maxHarmonics = 30) {
//   const longueurs = Object.values(phasors).map((slots) => slots.length);

//   // Vérif équilibre des conducteurs
//   if (new Set(longueurs).size > 1) {
//     if (!silent) {
//       console.warn("⚠️ Déséquilibre entre phases :", longueurs);
//     }
//   } else {
//     if (!silent) console.log("✅ Nombre équilibré de conducteurs par phase");
//   }

//   const Q = nbSlots;
//   const N = m;
//   const p = nbPoles / 2;

//   // Distribution des conducteurs
//   const u = conductorsDistribution.map((row) => row[0]);
//   const Npoints = u.length * interpolationFactor;
//   const x = Array.from({ length: Npoints }, (_, i) => u[i % nbSlots]);

//   // FFT
//   const f = new FFT(Npoints);
//   const out = new Array(Npoints).fill(0).map(() => [0, 0]); // Complex output
//   f.realTransform(out, x);
//   f.completeSpectrum(out);

//   // Normalisation
//   const KwVspaceNorm = out.map(([re, im]) => math.complex(re, im).div(Npoints));

//   // Remappage indices électriques
//   const indices = Array.from({ length: KwVspaceNorm.length }, (_, k) =>
//     Math.round((interpolationFactor * (p * k)) % KwVspaceNorm.length)
//   );
//   const KwHElec = indices.map((i) => KwVspaceNorm[i]);

//   // Fondamentale
//   const kwFundamental = math.abs(KwHElec[1]);

//   // Harmoniques (optionnel)
//   if (showHarmonics) {
//     const harmonics = KwHElec.map((c) => math.abs(c));
//     console.log("📊 Amplitudes harmoniques :", harmonics.slice(0, maxHarmonics));
//   }

//   return [kwFundamental, KwHElec];
// }

/* ===========================
   8) Orchestrateur
=========================== */
function showWinding({m=3, nb_poles=14, nb_slots=12, nb_layers=2, raccourcissement=1, plot_end_turns=false, electrical=false}){
  clearPlot();
  // arrière-plan stator & rot
  if(electrical){
    drawMagnets(2);
    const sectors = [
  { center: 0,            width: Math.PI/3, color: "red"   }, // phase A
  { center: 2*Math.PI/3,  width: Math.PI/3, color: "blue"  }, // phase B
  { center: 4*Math.PI/3,  width: Math.PI/3, color: "green" }  // phase C
];

    // Dessin sur le canvas
    // const canvas = document.getElementById("plot");
    // const ctx = canvas.getContext("2d");
    showSectors(ctx, sectors);

  }
  else{
  drawMagnets(nb_poles);
  if(raccourcissement === 1){drawStator(nb_slots,nb_layers/2);}
  else{drawStator(nb_slots,nb_layers);}
  
  }
  const { f_torque, nb_of_identic_sections, winding_type, warning_flag:warn1 } =
    calculateWindingCharacteristics(m, nb_slots, nb_poles, nb_layers, raccourcissement);

  const { phasors, Conductors_distribution, warning_flag:warn2 } =
    starOfSlots(winding_type, m, nb_poles, nb_slots, nb_layers, {
      electrical, raccourcissement, plotEndTurns: plot_end_turns, legend:false, silent:true
    });

  const kw = calculerFacteurDeBobinage(phasors, Conductors_distribution, nb_slots, nb_poles, m);
  return {
    kw, torque_ripple_freq: f_torque, identical_sections: nb_of_identic_sections,
    winding_type, warning_flag: (warn1 || warn2)
  };
}

/* ===========================
   9) UI + logique
=========================== */
const $poles = document.getElementById('poles');
const $slots = document.getElementById('slots');
const $layers = document.getElementById('layers');
const $coil  = document.getElementById('coilSpan');
const $endT  = document.getElementById('endTurns');
const $elec  = document.getElementById('elecDomain');
const $go    = document.getElementById('go');
const $msg   = document.getElementById('messages');

function fillSelect($el, values, sel){
  $el.innerHTML = '';
  values.forEach(v=>{
    const opt = document.createElement('option');
    opt.value = v; opt.textContent = v;
    if (sel!=null && +v===+sel) opt.selected = true;
    $el.appendChild(opt);
  });
}
fillSelect($poles, Array.from({length:20},(_,i)=>2*(i+1)), 10);
fillSelect($slots, Array.from({length:20},(_,i)=>3*(i+1)), 12);

// function refreshDynamic(){
//   $msg.textContent = '';
//   const m = 3;
//   const poles = +$poles.value;
//   const slots = +$slots.value;

//   // // couches
//   // const L = layersPossibilitiesList(slots, poles);
//   // let defaultLayers;
//   // if (slots/(m*poles) < 1) defaultLayers = 2; else defaultLayers = L[0];
//   // fillSelect($layers, L, defaultLayers); // ne permet pas de modifier le nombre de couches, erreur !

//   // couches
// const L = layersPossibilitiesList(slots, poles);
// let defaultLayers;

// if (!$layers.value) { // seulement si aucune valeur choisie
//   if (slots / (m * poles) < 1) {
//     defaultLayers = 2;
//   } else {
//     defaultLayers = L[0];
//   }
// } else {
//   defaultLayers = $layers.value; // garder la sélection de l’utilisateur
// }

// fillSelect($layers, L, defaultLayers);

//   // pas de bobine
//   const coilList = coilSpanPossibilitiesList(+$layers.value, slots, poles).sort((a,b)=>b-a);
//   let defaultSpan = (slots/(m*poles) < 1) ? 1 : Math.max(1, Math.floor(slots/poles));
//   if (!coilList.includes(defaultSpan)) defaultSpan = coilList[0] ?? 1;
//   fillSelect($coil, coilList, defaultSpan);
// }
// --- variables mémoire (globales au script) ---
let prevSlots = null;
let prevPoles = null;
let prevQIsInteger = null;

// utilitaire : test d'entier avec tolérance
function isIntegerTol(x, tol = 1e-9) {
  return Math.abs(x - Math.round(x)) < tol;
}

function refreshDynamic(){
  $msg.textContent = '';
  const m = 3;
  const poles = +$poles.value;
  const slots = +$slots.value;

  // liste possible des couches pour ces dimensions
  const L = layersPossibilitiesList(slots, poles);

  // calcul du q (encoches par pôle et par phase)
  const q = slots / (m * poles );
  const qIsInteger = isIntegerTol(q);
  console.log('q=', q, 'qIsInteger=', qIsInteger, 'slots=', slots, 'poles=', poles);


  // détecter si l'utilisateur a déjà choisi un nombre de couches
  const userHasChosenLayers = $layers.value !== "" && $layers.value != null;

  let defaultLayers;

  // --- première visite (initialisation) ---
  if (prevSlots === null || prevPoles === null) {
    // cas initial
    if (qIsInteger) {
      defaultLayers = 1; // si q entier, on met 1 par défaut au premier affichage
    } else if (slots / (m * poles) < 1) {
      defaultLayers = 2;
    } else {
      defaultLayers = L[0];
    }

  } else {
    // --- on vient d'un changement (slots/poles) ---
    const slotsOrPolesChanged = (slots !== prevSlots) || (poles !== prevPoles);

    if (slotsOrPolesChanged && prevQIsInteger === false && qIsInteger === true) {
      // ON VIENT DE PASSER d'un q NON entier -> q ENTIER : on met 1
      console.log('ON VIENT DE PASSER d un q NON entier -> q ENTIER : on met le nombre de couche à 1');

      defaultLayers = 1;
    } else {

      // si l'utilisateur n'a pas choisi lui-même, appliquer règles par défaut
      if (!userHasChosenLayers) {
        if (qIsInteger) {
          defaultLayers = 1;
        } else if (slots / (m * poles) < 1) {
          defaultLayers = 2;
        } else {
          defaultLayers = L[0];
        }
      } else {
        // garder la sélection utilisateur si elle est valide dans L
        const userVal = +$layers.value;
        if (L.includes(userVal)) defaultLayers = userVal;
        else defaultLayers = (qIsInteger ? 1 : L[0]);
      }
    }
  }

  // remplir le select des couches avec la liste possible (L) et la valeur par défaut choisie
  fillSelect($layers, L, defaultLayers);

  // recalculer / remplir le coil span en fonction de la couche sélectionnée
  // si bobinage a pas entier nombre de couche non pair est possible
  const coilList = coilSpanPossibilitiesList(+ $layers.value, slots, poles).sort((a,b)=>b-a);
  let defaultSpan = (slots/(m*poles) < 1) ? 1 : Math.max(1, Math.floor(slots/poles));
  if (!coilList.includes(defaultSpan)) defaultSpan = coilList[0] ?? 1;
  fillSelect($coil, coilList, defaultSpan);

  // mettre à jour la mémoire pour la prochaine exécution
  prevSlots = slots;
  prevPoles = poles;
  prevQIsInteger = qIsInteger;

}



// console.log('q=', q, 'qIsInteger=', qIsInteger, 'prevQIsInteger=', prevQIsInteger,
//             'prevSlots=', prevSlots, 'prevPoles=', prevPoles, 'userHasChosenLayers=', userHasChosenLayers);




$poles.addEventListener('change', refreshDynamic);
$slots.addEventListener('change', refreshDynamic);
$layers.addEventListener('change', refreshDynamic);
$slots.addEventListener('input', refreshDynamic);
refreshDynamic();

$go.addEventListener('click', ()=>{
  try{
    const m = 3;
    const poles = +$poles.value;
    const slots = +$slots.value;
    const layers = +$layers.value;
    const coil   = +$coil.value;
    const endTurns = +$endT.value===1;
    const elec   = +$elec.value===1;

    // validations
    if (poles%2 !== 0) throw new Error("❌ Le nombre de pôles doit être pair.");
    if (slots%3 !== 0) throw new Error("❌ Le nombre d’encoches doit être un multiple de 3.");
    if (layers < 1 || layers > 30) throw new Error("❌ Le nombre de couches doit être entre 1 et 30.");
    if (layers === 1 && ((slots % 2 === 1) ))//|| (coil % 2 === 0)))
    // if (layers === 1 && ((slots % 2 === 1) || coil % 2 === 0))
      throw new Error("❌ Bobinage à une couche non faisable.");
    if ((layers * slots / 2) !== Math.floor(layers * slots / 2))
      throw new Error("❌ Les trois phases ont un nombre déséquilibré de conducteurs.");
    if ((slots / (m * gcd(slots, parseInt(poles/2,10)))) !== Math.floor(slots / (m * gcd(slots, parseInt(poles/2,10)))))
      throw new Error("❌ Bobinage non équilibré (slots / (m * pgcd) non entier).");

    const res = showWinding({
      m, nb_poles:poles, nb_slots:slots, nb_layers:layers,
      raccourcissement:coil, plot_end_turns:endTurns, electrical:elec
    });

    document.getElementById('kw').textContent = res.kw.toFixed(3);
    document.getElementById('torque').textContent = String(res.torque_ripple_freq);
    document.getElementById('sections').textContent = String(res.identical_sections);
    document.getElementById('wtype').textContent = res.winding_type;

    if (res.warning_flag){
      $msg.innerHTML = "<span class='warn'>⚠️ Attention : la machine ne peut pas être bobinée complètement de manière équilibrée, ou présente des risques (q trop faible, pas de symétrie…).</span>";
    } else {
      $msg.innerHTML = "<span class='good'>✅ OK</span>";
    }
  } catch (e){
    $msg.innerHTML = "<span class='bad'>" + e.message + "</span>";
  }
});

// © 2025 Granizo Maxime. Tous droits réservés.

$go.click();
</script>
</body>
</html>
