<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visualisation de bobinage</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #141822;
    --plot-bg: #1e1e1e; /* pas noir noir */
    --fg: #e6e6e6;
    --muted: #9aa4b2;
    --accent: #6ea8fe;
    --bad: #ff7676;
    --warn: #ffc86b;
    --good: #66d587;
  }
  html, body {
    margin: 0; padding: 0; background: var(--bg); color: var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  .wrap {
    max-width: 1100px; margin: 24px auto; padding: 0 16px;
  }
  h1 { font-size: 22px; margin: 0 0 16px; font-weight: 700; }
  .grid {
    display: grid; gap: 16px;
    grid-template-columns: 320px 1fr;
  }
  .card {
    background: var(--panel); border-radius: 14px; padding: 14px 14px 10px; box-shadow: 0 6px 20px rgb(0 0 0 / 25%);
  }
  .controls label { display: block; font-size: 12px; color: var(--muted); margin: 10px 0 6px; }
  select, input[type="number"]{
    width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #2a3142;
    background: #0f1320; color: var(--fg); outline: none;
  }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
  .btn {
    display: inline-block; background: var(--accent); color: #0b1220; font-weight: 700;
    padding: 10px 12px; border-radius: 10px; border: none; cursor: pointer; margin-top: 10px;
  }
  .btn:active { transform: translateY(1px); }
  .plot-card { position: relative; }
  canvas { width: 100%; aspect-ratio: 1 / 1; background: var(--plot-bg); border-radius: 14px; display: block; }
  .legend { font-size: 12px; color: var(--muted); margin-top: 8px; }

  .kpi {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 10px;
  margin-top: 10px;
}
.kpi .box {
  background: #0f1320;
  border: 1px solid #2a3142;
  border-radius: 12px;
  padding: 10px;
}


  
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .note { color: var(--muted); font-size: 12px; }
  .warn { color: var(--warn); }
  .bad  { color: var(--bad); }
  .good { color: var(--good); }
  @media (max-width: 960px) { .grid { grid-template-columns: 1fr; } /*canvas { height: 520px; }*/ }
</style>
</head>
<body>
<div class="wrap">
  <h1>Visualisation du bobinage d’une machine électrique</h1>
  <div class="grid">
    <div class="card controls">
      <div class="row">
        <div>
          <label>Nombre de pôles</label>
          <select id="poles"></select>
        </div>
        <div>
          <label>Nombre d’encoches</label>
          <select id="slots"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Nombre de couches</label>
          <select id="layers"></select>
        </div>
        <div>
          <label>Pas de bobine (en nombre d'encoches)</label>
          <select id="coilSpan"></select>
        </div>
      </div>
      <div class="row">
        <div>
          <label>Afficher têtes de bobines ?</label>
          <select id="endTurns">
            <option value="1">Oui</option>
            <option value="0" selected>Non</option>
          </select>
        </div>
        <div>
          <label>Voir domaine électrique ?</label>
          <select id="elecDomain">
            <option value="1">Oui</option>
            <option value="0" selected>Non</option>
          </select>
        </div>
      </div>
      <button class="btn" id="go">Tracer / Calculer</button>
      <div class="note" id="messages"></div>
      <div class="kpi">
        <div class="box"><div class="note">Facteur de bobinage | <span class="mono">kw</span></div><div id="kw" class="mono">–</div></div>
        <div class="box"><div class="note">Ondulations couple (par tour)</div><div id="torque" class="mono">–</div></div>
        <div class="box"><div class="note">Sections identiques</div><div id="sections" class="mono">–</div></div>
        <div class="box"><div class="note">Type</div><div id="wtype" class="mono">–</div></div>
      </div>
    </div>

    <div class="card plot-card">
      <canvas id="plot" width="1000" height="1000"></canvas>
      <div class="legend">© 2025 Granizo Maxime. Tous droits réservés.      </div>
    </div>
  </div>
</div>

<script>
/* ===========================
   1) Petites utilitaires
=========================== */
const TAU = Math.PI * 2;
const clamp = (x,a,b)=>Math.min(b,Math.max(a,x));
function deg(x){ return x*180/Math.PI; }
function mod(a, n){ return ((a % n) + n) % n; }
function numberToLetter(n){ return String.fromCharCode('a'.charCodeAt(0) + (parseInt(n,10) - 1)); }
function angleInSector(angle, center, width){
  angle = +angle; center = +center;
  angle = +(mod(angle, TAU)).toFixed(6);
  center = mod(center, TAU);
  const half = width/2;
  const lower = +(mod(center - half, TAU)).toFixed(6);
  const upper = +(mod(center + half, TAU)).toFixed(6);
  if (lower < upper) return (lower < angle && angle <= upper);
  return (angle > lower || angle <= upper);
}

/* ===========================
   2) Listes dynamiques
=========================== */
function layersPossibilitiesList(nb_slot, nb_pole){
  nb_slot = +nb_slot; nb_pole = +nb_pole;
  // même logique que ton app.py
  if (parseInt(nb_slot/2) !== nb_slot/2){
    return [2,4,6,8];
  } else {
    return [1,2,4,6,8];
  }
}
function coilSpanPossibilitiesList(nb_layer, nb_slot, nb_pole){
  nb_layer = +nb_layer; nb_slot = +nb_slot; nb_pole = +nb_pole;
  const m = 3;
  if (nb_slot/(nb_pole*m) < 1) return [1];
  const arr = [];
  for (let k=Math.floor(nb_slot/2); k>=1; k--) arr.push(k);
  return arr;
}

/* ===========================
   3) Caractéristiques bobinage
=========================== */
function ppcm(a,b){ return (a*b)/gcd(a,b); }
function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=b; b=a%b; a=t; } return a; }

function calculateWindingCharacteristics(m, Ns, p, nb_layers, coil_span, silent=false){
  m=+m; Ns=+Ns; p=+p; nb_layers=+nb_layers; coil_span=+coil_span;
  const q = Ns / p / m;               // encoches/pôle/phase
  const pole_pairs = p/2;
  const f_torque = ppcm(p, Ns);       // fréq. ondulations (par tour)
  const nb_of_identic_sections = gcd(Ns, p); // sections identiques
  // Heuristique type de bobinage (aligné avec ton app.py)
  let winding_type = '';
  // if (Ns/(m*p) < 1){
  //   winding_type = 'Bobinage concentré';
  // } else {
    if (coil_span === 1){
      winding_type = 'Bobinage à pas dentaire';
    } else if (Number.isInteger(Ns/(m*p))){
      winding_type = 'Bobinage distribué à nombre d’encoches par pôle et par phase entier';
    } else {
      winding_type = 'Bobinage distribué à pas raccourcit';
    }
  //}
  // drapeaux d’avertissement
  let warning_flag = false;
  if (q < 0.25) warning_flag = true;
  // if (nb_of_identic_sections < 2) warning_flag = true;
  const S = (Ns/(m*gcd(Ns, parseInt(p/2,10))));
  if (S - Math.floor(S) > 0) warning_flag = true;

  return { f_torque, nb_of_identic_sections, winding_type, warning_flag };
}

/* ===========================
   4) FFT minimale (DFT) pour kw
=========================== */
function dftComplex(x){
  // x: array de réels → retourne spectre complexe {re, im}
  const N = x.length;
  const out = new Array(N).fill(0).map(()=>({re:0, im:0}));
  for (let k=0; k<N; k++){
    let re=0, im=0;
    for (let n=0; n<N; n++){
      const ang = -2*Math.PI*k*n/N;
      const c = Math.cos(ang), s = Math.sin(ang);
      re += x[n]*c; im += x[n]*s;
    }
    out[k] = {re, im};
  }
  return out;
}
function complexAbs(z){ return Math.hypot(z.re, z.im); }

/* ===========================
   5) Dessins (canvas)
=========================== */
const canvas = document.getElementById('plot');
const ctx = canvas.getContext('2d');

function clearPlot(){
  ctx.save();
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--plot-bg');
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.restore();
}
// conv polaire → écran
function P(r, th, cx, cy, scale){
  return [cx + r*Math.cos(th)*scale, cy + r*Math.sin(th)*scale];
}


function drawStator(nb_slots,nb_layer){
  const cx = canvas.width/2, cy = canvas.height/2, scale = 380;
  const rBase = 0.85 + 0.05 * nb_layer;         // rayon extérieur des culasse
  const toothH = 0.23 + 0.05 * nb_layer;        // hauteur dent (radiale)
  const slotPitch = TAU/nb_slots;
  const statorThick = 0.1;    // épaisseur du stator

  ctx.save();
  ctx.strokeStyle = '#000000'; 
  ctx.fillStyle   = '#dadde4'; 
  ctx.globalAlpha = 0.35;

  const rInner = (rBase - statorThick) * scale;   // rayon intérieur
  const rOuter = rBase * scale;                   // rayon extérieur

  ctx.beginPath();

  // --- ANNEAU DU STATOR ---
  ctx.arc(cx, cy, rOuter, 0, TAU);        // cercle extérieur
  ctx.arc(cx, cy, rInner, 0, TAU, true);  // cercle intérieur (sens inverse)

  // --- DENTS ---
  for (let s=0; s<nb_slots; s++){
    const angle = (0.5+s) * slotPitch;
    const r1 = rBase - toothH, r2 = rBase;
    const w = slotPitch * 0.4;

    const [x1,y1] = P(r1, angle - w/2, cx, cy, scale);
    const [x2,y2] = P(r2, angle - w/2, cx, cy, scale);
    const [x3,y3] = P(r2, angle + w/2, cx, cy, scale);
    const [x4,y4] = P(r1, angle + w/2, cx, cy, scale);

    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.lineTo(x3,y3);
    ctx.lineTo(x4,y4);
    ctx.closePath();
  }

  // --- UN SEUL FILL/STROKE ---
  ctx.fill();
  // ctx.stroke();

  ctx.restore();


  // To do, ajouter les pole shoes / pied de dent
}



  
function drawMagnets(nb_poles){
  const cx = canvas.width/2, cy = canvas.height/2, scale=380;
  const polePitch = TAU/nb_poles;
  const rInner = 0.35, rOuter = 0.52;
  ctx.save();
  for (let k=0; k<nb_poles; k++){
    const start = k*polePitch, end = (k+1)*polePitch;
    ctx.beginPath();
    // wedge
    ctx.moveTo(...P(0,0,cx,cy,scale));
    ctx.arc(cx,cy, rOuter*scale, start, end);
    ctx.lineTo(...P(rInner, end, cx,cy,scale));
    ctx.arc(cx,cy, rInner*scale, end, start, true);
    ctx.closePath();
    ctx.fillStyle = (k%2===0) ? 'rgba(255,80,80,0.6)' : 'rgba(80,140,255,0.6)';
    ctx.fill();
  }
  ctx.restore();
}

/* ===========================
   6) Star of slots + distribution
=========================== */ 
// si bobinage a pas ntier nombre de couche non pair est possible + forcer à une couche
  function starOfSlots(winding_type, m, nb_poles, nb_slots, nb_layers, options){ 
  const { electrical=false, raccourcissement=0, plotEndTurns=false, legend=false, silent=true } = options||{};
  const poles_pair = nb_poles/2;
  const phaseLabels = ['A','B','C','D','E','F'].slice(0,m);
  const phaseColors = ['#ff4d4d','#4d80ff','#31c159','#ffa640','#a56bff','#27c0d8'].slice(0,m);
  const sectorWidth = Math.PI/m;
  const slotPitch = 2*Math.PI/nb_slots;
  const phasors = Object.fromEntries(phaseLabels.map(L=>[L,[]]));
  const CD = Array.from({length: nb_slots}, ()=>Array(m).fill(0));
  let warning_flag = false;

  let coil_span_nb = 1;
  if (winding_type.includes("raccourcit") || winding_type.includes("entier")){
    coil_span_nb = Math.max(1, +raccourcissement);
  }
  const turnsWeight = 1/Math.max(nb_layers,1);

  let previous_slot = -1;

  for (let k=0; k<Math.floor(nb_layers*nb_slots/2); k++){
    // Détermination de la bobine aller/retour
    let go = (previous_slot + 1) % nb_slots;
    let ret = (go + coil_span_nb) % nb_slots;
    let counter = 0;
    while ((Math.abs(CD[go].reduce((a,b)=>a+Math.abs(b),0)) >= 1 ||
            Math.abs(CD[ret].reduce((a,b)=>a+Math.abs(b),0)) >= 1) && counter <= go){
      go = (go + 1) % nb_slots;
      ret = (go + coil_span_nb) % nb_slots;
      counter++;
    }
    if (counter > go){
      if(!silent) console.log("⚠️ Winding not possible at idx", k);
      warning_flag = true;
    }

    previous_slot = go;

    const angle_mech = -go*slotPitch;
    const angle_elec = angle_mech*poles_pair + Math.PI/6;

    // Attribution phase et polarité
    let phaseIdx=-1, polarity=1;
    for (let j=0;j<m;j++){
      const centerPos = -2*Math.PI*j/m;
      const centerNeg = centerPos + Math.PI;
      if (angleInSector(angle_elec, centerPos, sectorWidth)){ phaseIdx=j; polarity=+1; break; }
      if (angleInSector(angle_elec, centerNeg, sectorWidth)){ phaseIdx=j; polarity=-1; break; }
    }
    if (phaseIdx<0){ warning_flag=true; continue; }

    // Mise à jour de la distribution des conducteurs
    CD[go][phaseIdx] +=  polarity*turnsWeight;
    CD[ret][phaseIdx] += -polarity*turnsWeight;

    // Stockage des phasors pour le tracé électrique
    const phaseLbl = phaseLabels[phaseIdx];
    if(electrical) phasors[phaseLbl].push({slot: go, sign: polarity});
  }

  // ==================== TRACÉ ====================
  
  if (electrical) {
  ctx.save();
  const cx = canvas.width / 2, cy = canvas.height / 2, scale = 380;
  const radiusPhasor = 0.7;  // longueur du phasor
  const labelRadius = 0.8;   // rayon pour placer le texte
  const delta = 0.09;        // espacement radial entre conducteurs superposés

  // compteur pour gérer la superposition des labels par angle
  const labelCountAtAngle = {};

  for (let s = 0; s < nb_slots; s++) {
    for (let j = 0; j < m; j++) {
      const w = CD[s][j];
      if (w === 0) continue;

      const color = phaseColors[j];
      const theta = s * slotPitch * poles_pair;  // angle mécanique * paires de pôles

      // clé arrondie pour éviter les problèmes de flottants
      const key = Math.round(theta * 1e6) / 1e6;

      // nombre de conducteurs à cet angle déjà placés
      let nLabel = labelCountAtAngle[key] || 0;

      // nombre de conducteurs à tracer pour cette phase et slot
      const nConductors = Math.round(Math.abs(w) * nb_layers);

      // tracer tous les conducteurs
      for (let k = 0; k < nConductors; k++) {
        // coordonnées du phasor
        const [x, y] = P(radiusPhasor, theta, cx, cy, scale);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x, y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5 + 0.5 * nLabel;
        ctx.stroke();

        // symbole : rond pour positif, croix pour négatif
        if (w > 0) {
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.moveTo(x - 6, y - 6);
          ctx.lineTo(x + 6, y + 6);
          ctx.moveTo(x - 6, y + 6);
          ctx.lineTo(x + 6, y - 6);
          ctx.lineWidth = 1.5 + 0.5 * nLabel;
          ctx.strokeStyle = color;
          ctx.stroke();
        }

        // texte radialement décalé pour éviter superposition
        const [xt, yt] = P(labelRadius + nLabel * delta, theta, cx, cy, scale);
        ctx.fillStyle = color;
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(`S${s + 1}` + (w > 0 ? "+" : "-"), xt, yt);

        // incrément compteur pour ce slot/angle
        nLabel++;
      }

      // mettre à jour le compteur global pour cet angle
      labelCountAtAngle[key] = nLabel;
    }
  }

  ctx.restore();
}
 
  
  else { // Domaine mécanique
   

ctx.save();
ctx.font = "14px Arial";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
const cx = canvas.width / 2, cy = canvas.height / 2, scale = 380;

const labelRadiusBase = 0.75; // rayon de base pour le label
const angleOffset = 0.04;      // petit décalage angulaire pour bobinage concentré

const slotConductorsCount = Array(nb_slots).fill(0).map(()=>0);


// objet pour stocker les positions des labels pour chaque slot, phase et signe
// const labelPositions = Array(nb_slots).fill(0).map(()=>Array(m).fill(0).map(()=>({"+":[], "-":[] })));
const labelPositions = Array(nb_slots).fill(0).map(() =>
  Array(m).fill(0).map(() => ({ "+": [], "-": [] }))
);


for(let s=0; s<nb_slots; s++){ // itère sur les slots
  for(let j=0; j<m; j++){      // itère sur les phases
    const w = CD[s][j];
    if(w === 0) continue;

    const color = phaseColors[j];
    const thetaBase = s * slotPitch;

    // nombre de conducteurs dans cette slot pour cette phase
    const nConductors = Math.round(Math.abs(w) * nb_layers);

    for(let k=0; k<nConductors; k++){  // répéter pour chaque conducteur

      const label = phaseLabels[j] + (w>0 ? "+" : "-");

      let thetaLabel, radiusLabel;
      radiusLabel = labelRadiusBase;

      if (winding_type.includes("Bobinage à pas dentaire")) {  // Concentré :  petit décalage angulaire

  const radiusMin = labelRadiusBase;
  const radiusMax = labelRadiusBase + 0.05 * (nb_layers - 1);


  
  slotConductorsCount[s] += 1; // conducteur suivant dans la même encoche

if (nb_layers==1) {thetaLabel = thetaBase}
else{
    if(CD[(s+1)%nb_slots][j]>0 || CD[(s+1)%nb_slots][j]<0) { // si il y a un autre conducteur au slot suivant
       
      if(CD[(s+nb_slots-1)%nb_slots][j]>0 || CD[(s+nb_slots-1)%nb_slots][j]<0) { // si il y a un autre conducteur au slot précédent aussi  
        thetaLabel = thetaBase - angleOffset + (slotConductorsCount[s]-1)%2 *2*  angleOffset ;  // répartir droite/gauche
        if(nb_layers>2){radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *Math.floor(k/2) ;}
      }

      else{
      thetaLabel = thetaBase + angleOffset;   // si conducteur même phase au slot suivant mais pas au slot précédent : côté droit
      if(nb_layers>2){radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *(k) ;}

          }
    }
    else {         // sinon, si pas de conducteur au slot suivant, on met à gauche
        thetaLabel = thetaBase - angleOffset;
        if(nb_layers>2){radiusLabel = radiusMin + (radiusMax - radiusMin)/ (nb_layers - 1) *(k) ;}

      }
      
    }

  
} else {
  // Distribué : répartir les conducteurs uniformément selon la couche
  const radiusMin = labelRadiusBase;
  const radiusMax = labelRadiusBase + 0.05 * (nb_layers - 1);

  if(nb_layers==1){radiusLabel = radiusMin ;}
  else{
  radiusLabel = radiusMin + (radiusMax - radiusMin) * slotConductorsCount[s] / (nb_layers - 1);}
  slotConductorsCount[s] += 1; // conducteur suivant

  thetaLabel = thetaBase;
}


      const [xt, yt] = P(radiusLabel, thetaLabel, cx, cy, scale);
      ctx.fillStyle = color;
      ctx.fillText(label, xt, yt);

      // enregistrer la position pour le tracé de tête de bobine
      // let signe;
      // signe = w>0 ? "+" : "-";

      // labelPositions[s][j][signe].push({xt, yt});

      // const sign = w > 0 ? "+" : "-";
      // labelPositions[s][j][sign].push({x: xt, y: yt});
      const sign = w > 0 ? "+" : "-";
      labelPositions[s][j][sign].push({x: xt, y: yt, sign: sign});


      // console.log('signe :', sign);

      console.log('label :', label);
      console.log('labelPositions[s][j]:', labelPositions[s][j]);


    }
  }
}


ctx.restore();






if(plotEndTurns==true){

  console.log('Plot des bobines');
  // console.log('labelPositions', labelPositions);
  // console.log('CD', CD);
// ===========================================
// Tracé des têtes de bobine basé sur labelPositions
// ===========================================
ctx.save();
ctx.lineWidth = 1.2;
const offsetDistance = 15.0; // décalage depuis le bord du label
const cx = canvas.width / 2, cy = canvas.height / 2;

for (let s = 0; s < nb_slots; s++) {
  for (let j = 0; j < m; j++) {
    const color = phaseColors[j];

    // récupérer les positions + et -
    const plusPositions = labelPositions[s][j]["+"].slice();   // clone pour manipuler
    const minusPositions = labelPositions[s][j]["-"].slice();

    // parcourir toutes les positions positives
    for (let k = 0; k < plusPositions.length; k++) {
      const p = plusPositions[k];

      // slot de retour
      const retSlot = (s - coil_span_nb+ nb_slots) % nb_slots;
      
      // // A ajouter pour prendre en compte les fois ou le retour est de l'autre côté
      // if( labelPositions[(s - coil_span_nb+ nb_slots) % nb_slots)][j]["-"] != "" && non relié  ) {const retSlot = (s - coil_span_nb+ nb_slots) % nb_slots;} //il existe un conducteur de la bonne phase et polarité et non relié au slot n° (s - coil_span_nb+ nb_slots) % nb_slots) 
      // else {const retSlot = (s + coil_span_nb) % nb_slots;} 
      
      // récupérer le tableau de positions opposées pour le retour
      const retList = labelPositions[retSlot][j]["-"];
      if (!retList || retList.length === 0) continue;

      // prendre le premier point et le retirer pour ne pas le réutiliser
      const mPos = retList.shift();
      
      // enlever de labelPositions ou d'une copie, les deux conducteurs

      // vecteur unitaire pour offset
      const dx = mPos.x - p.x;
      const dy = mPos.y - p.y;
      const length = Math.sqrt(dx*dx + dy*dy);
      const ux = dx / length;
      const uy = dy / length;

      // tracer le trait
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(p.x + offsetDistance*ux, p.y + offsetDistance*uy);
      ctx.lineTo(mPos.x - offsetDistance*ux, mPos.y - offsetDistance*uy);
      ctx.stroke();
    }

    // pareil pour les positions négatives (optionnel si tu veux tracer - vers +)
    for (let k = 0; k < minusPositions.length; k++) {
      const p = minusPositions[k];

      const retSlot = (s + nb_slots - coil_span_nb) % nb_slots; // slot de retour pour négatif

      // même chose ici pour retslot

      const retList = labelPositions[retSlot][j]["+"];
      if (!retList || retList.length === 0) continue;

      const mPos = retList.shift();

      const dx = mPos.x - p.x;
      const dy = mPos.y - p.y;
      const length = Math.sqrt(dx*dx + dy*dy);
      const ux = dx / length;
      const uy = dy / length;

      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(p.x + offsetDistance*ux, p.y + offsetDistance*uy);
      ctx.lineTo(mPos.x - offsetDistance*ux, mPos.y - offsetDistance*uy);
      ctx.stroke();
    }
  }
}

ctx.restore();

  
}










  }




  return { phasors, Conductors_distribution: CD, warning_flag };
}




function showSectors(ctx, sectors) {
  const R = ctx.canvas.width / 2.5;
  const cx = ctx.canvas.width / 2;
  const cy = ctx.canvas.height / 2;

  ctx.save();

  sectors.forEach(sec => {
    const start = sec.center - sec.width / 2;
    const end   = sec.center + sec.width / 2;

    // --- secteur positif ---
    ctx.globalAlpha = 0.15;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, start, end, false);
    ctx.closePath();
    ctx.fillStyle = sec.color;
    ctx.fill();

    // --- secteur négatif (opposé) ---
    const startOpp = start + Math.PI;
    const endOpp   = end + Math.PI;
    ctx.globalAlpha = 0.07; // plus transparent
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, startOpp, endOpp, false);
    ctx.closePath();
    ctx.fillStyle = sec.color;
    ctx.fill();
  });

  ctx.restore();
}


/* ===========================
   7) Facteur de bobinage (Scuiller)
=========================== */
function calculerFacteurDeBobinage(phasors, CD, nb_slots, nb_poles, m){
  const Q = nb_slots, N = m, p = nb_poles/2;
  // vecteur spatial : (N/Q) * FFT(CD[:,0]) — on suit la colonne phase A
  const space = dftComplex(CD.map(row => row[0]||0)).map(z => ({re: (N/Q)*z.re, im: (N/Q)*z.im}));
  // remappage harmonique électrique : indices = mod(p * [0:Q-1], Q)
  const Kw_he = new Array(Q);
  for (let k=0; k<Q; k++){
    const idx = (p * k) % Q; // p peut être .5, mais dans notre cas nb_poles pair → p entier
    Kw_he[k] = space[idx];
  }
  const fundamental = Kw_he[1];
  return complexAbs(fundamental);
}

/* ===========================
   8) Orchestrateur
=========================== */
function showWinding({m=3, nb_poles=14, nb_slots=12, nb_layers=2, raccourcissement=1, plot_end_turns=false, electrical=false}){
  clearPlot();
  // arrière-plan stator & rot
  if(electrical){
    drawMagnets(2);
    const sectors = [
  { center: 0,            width: Math.PI/3, color: "red"   }, // phase A
  { center: 2*Math.PI/3,  width: Math.PI/3, color: "blue"  }, // phase B
  { center: 4*Math.PI/3,  width: Math.PI/3, color: "green" }  // phase C
];

// Dessin sur le canvas
// const canvas = document.getElementById("plot");
// const ctx = canvas.getContext("2d");
showSectors(ctx, sectors);


  }
  else{
  drawMagnets(nb_poles);
  drawStator(nb_slots,nb_layers);
  }
  const { f_torque, nb_of_identic_sections, winding_type, warning_flag:warn1 } =
    calculateWindingCharacteristics(m, nb_slots, nb_poles, nb_layers, raccourcissement);

  const { phasors, Conductors_distribution, warning_flag:warn2 } =
    starOfSlots(winding_type, m, nb_poles, nb_slots, nb_layers, {
      electrical, raccourcissement, plotEndTurns: plot_end_turns, legend:false, silent:true
    });

  const kw = calculerFacteurDeBobinage(phasors, Conductors_distribution, nb_slots, nb_poles, m);
  return {
    kw, torque_ripple_freq: f_torque, identical_sections: nb_of_identic_sections,
    winding_type, warning_flag: (warn1 || warn2)
  };
}

/* ===========================
   9) UI + logique
=========================== */
const $poles = document.getElementById('poles');
const $slots = document.getElementById('slots');
const $layers = document.getElementById('layers');
const $coil  = document.getElementById('coilSpan');
const $endT  = document.getElementById('endTurns');
const $elec  = document.getElementById('elecDomain');
const $go    = document.getElementById('go');
const $msg   = document.getElementById('messages');

function fillSelect($el, values, sel){
  $el.innerHTML = '';
  values.forEach(v=>{
    const opt = document.createElement('option');
    opt.value = v; opt.textContent = v;
    if (sel!=null && +v===+sel) opt.selected = true;
    $el.appendChild(opt);
  });
}
fillSelect($poles, Array.from({length:20},(_,i)=>2*(i+1)), 10);
fillSelect($slots, Array.from({length:20},(_,i)=>3*(i+1)), 12);

// function refreshDynamic(){
//   $msg.textContent = '';
//   const m = 3;
//   const poles = +$poles.value;
//   const slots = +$slots.value;

//   // // couches
//   // const L = layersPossibilitiesList(slots, poles);
//   // let defaultLayers;
//   // if (slots/(m*poles) < 1) defaultLayers = 2; else defaultLayers = L[0];
//   // fillSelect($layers, L, defaultLayers); // ne permet pas de modifier le nombre de couches, erreur !

//   // couches
// const L = layersPossibilitiesList(slots, poles);
// let defaultLayers;

// if (!$layers.value) { // seulement si aucune valeur choisie
//   if (slots / (m * poles) < 1) {
//     defaultLayers = 2;
//   } else {
//     defaultLayers = L[0];
//   }
// } else {
//   defaultLayers = $layers.value; // garder la sélection de l’utilisateur
// }

// fillSelect($layers, L, defaultLayers);

//   // pas de bobine
//   const coilList = coilSpanPossibilitiesList(+$layers.value, slots, poles).sort((a,b)=>b-a);
//   let defaultSpan = (slots/(m*poles) < 1) ? 1 : Math.max(1, Math.floor(slots/poles));
//   if (!coilList.includes(defaultSpan)) defaultSpan = coilList[0] ?? 1;
//   fillSelect($coil, coilList, defaultSpan);
// }
// --- variables mémoire (globales au script) ---
let prevSlots = null;
let prevPoles = null;
let prevQIsInteger = null;

// utilitaire : test d'entier avec tolérance
function isIntegerTol(x, tol = 1e-9) {
  return Math.abs(x - Math.round(x)) < tol;
}

function refreshDynamic(){
  $msg.textContent = '';
  const m = 3;
  const poles = +$poles.value;
  const slots = +$slots.value;

  // liste possible des couches pour ces dimensions
  const L = layersPossibilitiesList(slots, poles);

  // calcul du q (encoches par pôle et par phase)
  const q = slots / (m * poles );
  const qIsInteger = isIntegerTol(q);
  console.log('q=', q, 'qIsInteger=', qIsInteger, 'slots=', slots, 'poles=', poles);


  // détecter si l'utilisateur a déjà choisi un nombre de couches
  const userHasChosenLayers = $layers.value !== "" && $layers.value != null;

  let defaultLayers;

  // --- première visite (initialisation) ---
  if (prevSlots === null || prevPoles === null) {
    // cas initial
    if (qIsInteger) {
      defaultLayers = 1; // si q entier, on met 1 par défaut au premier affichage
    } else if (slots / (m * poles) < 1) {
      defaultLayers = 2;
    } else {
      defaultLayers = L[0];
    }

  } else {
    // --- on vient d'un changement (slots/poles) ---
    const slotsOrPolesChanged = (slots !== prevSlots) || (poles !== prevPoles);

    if (slotsOrPolesChanged && prevQIsInteger === false && qIsInteger === true) {
      // ON VIENT DE PASSER d'un q NON entier -> q ENTIER : on met 1
      console.log('ON VIENT DE PASSER d un q NON entier -> q ENTIER : on met le nombre de couche à 1');

      defaultLayers = 1;
    } else {

      // si l'utilisateur n'a pas choisi lui-même, appliquer règles par défaut
      if (!userHasChosenLayers) {
        if (qIsInteger) {
          defaultLayers = 1;
        } else if (slots / (m * poles) < 1) {
          defaultLayers = 2;
        } else {
          defaultLayers = L[0];
        }
      } else {
        // garder la sélection utilisateur si elle est valide dans L
        const userVal = +$layers.value;
        if (L.includes(userVal)) defaultLayers = userVal;
        else defaultLayers = (qIsInteger ? 1 : L[0]);
      }
    }
  }

  // remplir le select des couches avec la liste possible (L) et la valeur par défaut choisie
  fillSelect($layers, L, defaultLayers);

  // recalculer / remplir le coil span en fonction de la couche sélectionnée
  const coilList = coilSpanPossibilitiesList(+ $layers.value, slots, poles).sort((a,b)=>b-a);
  let defaultSpan = (slots/(m*poles) < 1) ? 1 : Math.max(1, Math.floor(slots/poles));
  if (!coilList.includes(defaultSpan)) defaultSpan = coilList[0] ?? 1;
  fillSelect($coil, coilList, defaultSpan);

  // mettre à jour la mémoire pour la prochaine exécution
  prevSlots = slots;
  prevPoles = poles;
  prevQIsInteger = qIsInteger;
  // if(qIsInteger == true) { console.log('qIsInteger');}
  //   else { console.log('q Is Not an Integer');}

}



// console.log('q=', q, 'qIsInteger=', qIsInteger, 'prevQIsInteger=', prevQIsInteger,
//             'prevSlots=', prevSlots, 'prevPoles=', prevPoles, 'userHasChosenLayers=', userHasChosenLayers);




$poles.addEventListener('change', refreshDynamic);
$slots.addEventListener('change', refreshDynamic);
$layers.addEventListener('change', refreshDynamic);
$slots.addEventListener('input', refreshDynamic);
refreshDynamic();

$go.addEventListener('click', ()=>{
  try{
    const m = 3;
    const poles = +$poles.value;
    const slots = +$slots.value;
    const layers = +$layers.value;
    const coil   = +$coil.value;
    const endTurns = +$endT.value===1;
    const elec   = +$elec.value===1;

    // validations (mêmes que app.py)
    if (poles%2 !== 0) throw new Error("❌ Le nombre de pôles doit être pair.");
    if (slots%3 !== 0) throw new Error("❌ Le nombre d’encoches doit être un multiple de 3.");
    if (layers < 1 || layers > 30) throw new Error("❌ Le nombre de couches doit être entre 1 et 30.");
    if (layers === 1 && ((slots % 2 === 1) ))//|| (coil % 2 === 0)))
      throw new Error("❌ Bobinage à une couche non faisable.");
    if ((layers * slots / 2) !== Math.floor(layers * slots / 2))
      throw new Error("❌ Les trois phases ont un nombre déséquilibré de conducteurs.");
    if ((slots / (m * gcd(slots, parseInt(poles/2,10)))) !== Math.floor(slots / (m * gcd(slots, parseInt(poles/2,10)))))
      throw new Error("❌ Bobinage non équilibré (slots / (m * pgcd) non entier).");

    const res = showWinding({
      m, nb_poles:poles, nb_slots:slots, nb_layers:layers,
      raccourcissement:coil, plot_end_turns:endTurns, electrical:elec
    });

    document.getElementById('kw').textContent = res.kw.toFixed(3);
    document.getElementById('torque').textContent = String(res.torque_ripple_freq);
    document.getElementById('sections').textContent = String(res.identical_sections);
    document.getElementById('wtype').textContent = res.winding_type;

    if (res.warning_flag){
      $msg.innerHTML = "<span class='warn'>⚠️ Attention : la machine ne peut pas être bobinée complètement de manière équilibrée, ou présente des risques (q trop faible, pas de symétrie…).</span>";
    } else {
      $msg.innerHTML = "<span class='good'>✅ OK</span>";
    }
  } catch (e){
    $msg.innerHTML = "<span class='bad'>" + e.message + "</span>";
  }
});

// © 2025 Granizo Maxime. Tous droits réservés.

$go.click();
</script>
</body>
</html>
